<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
<title>Операции JavaScript</title>
<script src="Script.js"></script>
<link rel="stylesheet" type="text/css" href="Style.css"/>
</head>
<body>

<h2>Операции JavaScript</h2>

<p>В Javascript есть все необходимые для программирования операторы, хотя нет их перегрузки.

Некоторые операторы( <code>+</code>, побитовые, логические, <code>===</code>) имеют специфические особенности.

В Javascript есть даже операторы <code>>>></code> и <code><<<</code>.

<h3 class="show" onclick="Click(this)">Арифметические</h3>
<div>
<xmp>    +   сложение
    -   вычитание
    *   умножение
    /   деление
    %   остаток от деления
</xmp>
В отличие от некоторых других языков, оператор "<code>+</code>" делает конкатенацию, если хотя бы один операнд - строка, причем, не обязательно первый.

Проверим:

Унарный оператор "+" также используется для преобразования строки к числу:
<xmp>
alert(+"123"+1) // 124
</xmp>
</div>

<h3 class="show" onclick="Click(this)">Побитовые</h3>
<div>
<xmp>
    &
    |
    ^
    >>
    >>>
    <<
</xmp>
<p>Все побитовые операции работают с 4-байтовым signed int.

<p>Операция <code>>>></code> сдвигает побитово вправо, а слева дополняет нулями. В результате эффект - тот же, что и при простом сдвиге <code>>></code> для положительных чисел.

Для отрицательных - все по-другому. Например, <code>-9</code> в битовом виде выглядит как: <code>11111111111111111111111111110111</code>.

Операция <code>>>></code> даст эффект: <code>-9 >>> 2</code> будет в битовом виде <code>00111111111111111111111111111101</code>, т.е <code>1073741821</code>.
</div>

<h3 class="show" onclick="Click(this)">Логические</h3>
<div>
    <code>&amp;&amp;</code> 
Логическое И. Возвращает последний операнд, если все операнды верны. Если хоть один из операндов неверен, то возвратит первый неверный операнд.

Например, 
<xmp>
1 && 2 = 2
1 && 0 && false === 0:
</xmp>
<p>Оператор И обычно используется, чтобы избежать ошибок при получении вложенных свойств объекта.
Например, нужно свойство petShop.animals.rabbit или ложное значение, если такого свойства нет.

Безопасный способ:
<xmp>
var rabbit = petShop && petShop.animals && petShop.animals.rabbit
</xmp>
Этот код корректно выполнится, даже если <code>petShop = false</code>, в то время как
<xmp>
var rabbit = petShop.animals.rabbit
</xmp>
выдаст ошибку (вызовет исключение) об отсутствующем свойстве.

  <p>  <code>||</code>
Оператор логического ИЛИ возвращает первое верное значение. А если верных значений вообще нет, то последнее неверное.
Это удобно использовать так:
<xmp>
var e = event || window.event // если event не событие, то берем window.event
</xmp>
    <code>!</code>
Логическое НЕ, также удобно для преобразования в Boolean.
<xmp>
	var str = "something"
	// эквивалентные записи
	var test = Boolean(str)
	var test = !!str
</xmp>
</div>

<h3 class="show" onclick="Click(this)">Сравнение</h3>
<div>
<xmp>
    ==
    !=
    <
    >
    <=
    >=
    ===
    !==
</xmp>
<p>Операторы больше-меньше также работают со строками, сравнивая их лексикографически, т.е посимвольно.
<xmp>
"B">"a"			// false  
"bc" < "bd"		// true
</xmp>

Сравнение <code>==</code> делается с приведением типов, а <code>===</code> без приведения типов, например:
<xmp>
0 == false  // верно
0 !== false  //типы разные
</xmp>
<p>Проверка равенства осуществляется особым образом, если один из операндов - <code>undefined</code>, <code>null</code>, <code>NaN</code>. 
Более подробно об алгоритме в этом случае можно прочитать в секции 11.9.3 стандарта ECMA-262.

<p><code>?</code>
Тернарный оператор. В старых парсерах javascript с ним были проблемы, надо было заключать сравнение в скобки, но в новых - вполне нормальный оператор
<xmp>
var test = (1==2) ? "one" : "two"
// эквивалентно
var test = 1==2 ? "one" : "two"
</xmp>
</div>

<h3 class="show" onclick="Click(this)">Задание</h3>
<div>
Напишите скрипт, 
</div>

<hr width="40%" align="center">
</body>
</html>