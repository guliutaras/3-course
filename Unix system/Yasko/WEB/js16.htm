<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
<title>Регулярные выражения</title>
<link rel="stylesheet" href="style.css" type="text/css" />
<script src="Script.js"></script>
<link rel="stylesheet" type="text/css" href="Style.css"/>
</head>
<body>

<h2>Регулярные выражения</h2>

<p>Регулярные выражения в javascript имеют особую краткую форму и стандартный PCRE-синтаксис.

Работают они через специальный объект RegExp.

Кроме того, у строк есть свои методы search,match,replace, но чтобы их понять - разберем-таки сначала RegExp.

<h3 class="show" onclick="Click(this)">Объект RegExp</h3>
<div>
<p>Объект типа RegExp, или, короче, регулярное выражение, можно создать двумя путями:
<xmp>
/pattern/флаги
new RegExp("pattern"[, флаги])
</xmp>
pattern - регулярное выражение для поиска (о замене - позже), а флаги - строка из любой комбинации символов g(глобальный поиск), i(регистр неважен) и m(многострочный поиск).

<p>Первый способ используется часто, второй - иногда. Например, два таких вызова эквивалентны:
<xmp>
var reg = /ab+c/i
var reg = new RegExp("ab+c", "i")
</xmp>
<p>При втором вызове - т.к регулярное выражение в кавычках, то нужно дублировать \
<xmp>
// эквивалентны
re = new RegExp("\\w+")
re = /\w+/
</xmp>
<p>При поиске можно использовать большинство возможностей современного PCRE-синтаксиса.
</div>

<h3 class="show" onclick="Click(this)">Спецсимволы в регулярном выражении</h3>
<div>
<table border=1 cellspacing=0>
<tbody><tr>
<td class="header">Символ</td>
<td class="header">Значение</td>
</tr>
<tr>
<td><code>\</code></td>
<td>Для обычных символов - делает их специальными. Например, выражение <code>/s/</code> ищет просто символ 's'. А если поставить \ перед s, то <code>/\s/</code> уже обозначает пробельный символ.И наоборот, если символ специальный, например *, то \ сделает его просто обычным символом "звездочка". Например,  <code>/a*/</code> ищет 0 или больше подряд идущих символов 'a'. Чтобы найти а со звездочкой 'a*' - поставим \ перед спец. символом: <code>/a\*/</code>.</td>
</tr>
<tr>
<td><code>^</code></td>
<td>Обозначает начало входных данных. Если установлен флаг многострочного поиска <code>("m")</code>, то также сработает при начале новой строки.Например, <code>/^A/</code> не найдет 'A' в "an A", но найдет первое 'A' в "An A."</td>
</tr>
<tr>
<td><code>$</code></td>
<td>Обозначает конец входных данных. Если установлен флаг многострочного поиска, то также сработает в конце строки.Например, <code>/t$/</code> не найдет 't' в "eater", но найдет - в "eat".</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Обозначает повторение 0 или более раз. Например, <code>/bo*/</code> найдет 'boooo' в "A ghost booooed" и 'b' в "A bird warbled", но ничего не найдет в "A goat grunted".</td>
</tr>
<tr>
<td><code>+</code></td>
<td>Обозначает повторение 1 или более раз. Эквивалентно <code>{1,}</code>. Например, <code>/a+/</code> найдет 'a' в "candy" и все 'a' в "caaaaaaandy".</td>
</tr>
<tr>
<td><code>?</code></td>
<td>Обозначает, что элемент может как присутствовать, так и отсутствовать. Например, <code>/e?le?/</code> найдет 'el' в "angel" и 'le' в "angle."Если используется сразу после одного из <code>квантификаторов *</code>, <code>+</code>, <code>?</code>, или <code>{}</code>, то задает "нежадный" поиск (повторение минимально возможное количество раз, до ближайшего следующего элемента паттерна), в противоположность "жадному" режиму по умолчанию, при котором количество повторений максимально, даже если следующий элемент паттерна тоже подходит.Кроме того, ? используется в предпросмотре, который описан в таблице под <code>(?=)</code>, <code>(?!)</code>, и <code>(?: )</code>.</td>
</tr>
<tr>
<td><code>.</code></td>
<td>(Десятичная точка) обозначает любой символ, кроме перевода строки: \n \r \u2028 or \u2029. (<code>можно использовать [\s\S] для поиска любого символа, включая переводы строк). Например, </code><code>/.n/</code> найдет 'an' и 'on' в "nay, an apple is on the tree", но не 'nay'.</td>
</tr>
<tr>
<td><code>(<code>x</code>)</code></td>
<td>Находит <code><code>x</code></code> и запоминает. Это называется "запоминающие скобки". Например, <code>/(foo)/</code> найдет и запомнит 'foo' в "foo bar." Найденная подстрока хранится в массиве-результате поиска или в предопределенных свойствах объекта RegExp:<code></code><code></code> <code>$1, ..., $9</code>.Кроме того, скобки объединяют то, что в них находится, в единый элемент паттерна. Например, (abc)* - повторение abc 0 и более раз.</td>
</tr>
<tr>
<td><code>(?:<code>x</code>)</code></td>
<td>Находит <code><code>x</code></code>, но не запоминает найденное. Это называется "незапоминающие скобки". Найденная подстрока не сохраняется в массиве результатов и свойствах RegExp.Как и все скобки, объединяют  находящееся в них в единый подпаттерн.</td>
</tr>
<tr>
<td><code><code>x</code>(?=<code>y</code>)</code></td>
<td>Находит <code><code>x</code></code>, только если за <code><code>x</code></code> следует <code><code>y</code></code>. Например, <code>/Jack(?=Sprat)/</code> найдет 'Jack', только если за ним следует 'Sprat'. <code>/Jack(?=Sprat|Frost)/</code> найдет 'Jack', только если за ним следует 'Sprat' или 'Frost'. Однако, ни 'Sprat' ни 'Frost' не войдут в результат поиска.</td>
</tr>
<tr>
<td><code><code>x</code>(?!<code>y</code>)</code></td>
<td>Находит <code><code>x</code></code>, только если за <code><code>x</code></code> не следует <code><code>y</code></code>. Например, <code>/\d+(?!\.)/</code> найдет число, только если за ним не следует десятичная точка. <code>/\d+(?!\.)/.exec("3.141")</code> найдет 141, но не 3.141.</td>
</tr>
<tr>
<td><code><code>x</code>|<code>y</code></code></td>
<td>Находит <code><code>x</code></code> или <code><code>y</code></code>. Например, <code>/green|red/</code> найдет 'green' в "green apple" и 'red' в "red apple."</td>
</tr>
<tr>
<td><code>{<code>n</code>}</code></td>
<td>Где n - положительное целое число. Находит ровно n повторений предшествующего элемента. Например, <code>/a{2}/</code> не найдет 'a' в "candy," но найдет оба a в "caandy," и первые два a в "caaandy."</td>
</tr>
<tr>
<td><code>{<code>n</code>,}</code></td>
<td>Где n - положительное целое число. Находит n и более повторений элемента. Например, <code>/a{2,}</code> не найдет 'a' в "candy", но найдет все 'a' в "caandy" и в "caaaaaaandy."</td>
</tr>
<tr>
<td><code>{<code>n</code>,<code>m</code>}</code></td>
<td>Где n и m - положительные целые числа. Находят от n до m повторений элемента.</td>
</tr>
<tr>
<td><code>[<code>xyz</code>]</code></td>
<td>Набор символов. Находит любой из перечисленных символов. Вы можете указать промежуток, используя тире. Например, <code>[abcd]</code> - то же самое, что <code>[a-d]</code>. Найдет 'b' в "brisket", а также 'a' и 'c' в "ache".</td>
</tr>
<tr>
<td><code>[^<code>xyz</code>]</code></td>
<td>Любой символ, кроме указанных в наборе. Вы также можете указать промежуток. Например, <code>[^abc]</code> - то же самое, что <code>[^a-c]</code>. Найдет 'r' в "brisket" и 'h' в "chop."</td>
</tr>
<tr>
<td><code>[\b]</code></td>
<td>Находит символ backspace. (Не путать с <code>\b</code>.)</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>Находит границу слов (латинских), например пробел. (Не путать с <code>[\b]</code>). Например, <code>/\bn\w/</code> найдет 'no' в "noonday"; <code>/\wy\b/</code> найдет 'ly' в "possibly yesterday."</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>Обозначает не границу слов. Например,  <code>/\w\Bn/</code> найдет 'on' в "noonday", а <code>/y\B\w/</code> найдет 'ye' в "possibly yesterday."</td>
</tr>
<tr>
<td><code>\c<code>X</code></code></td>
<td><code><code>Где </code></code><code><code>X</code></code> - буква от A до Z. Обозначает контрольный символ в строке. Например, <code>/\cM/</code> обозначает символ Ctrl-M.</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>находит цифру из любого алфавита (у нас же юникод). Испльзуйте <code>[0-9], чтобы найти только обычные цифры. Например, </code><code>/\d/</code> или <code>/[0-9]/</code> найдет '2' в "B2 is the suite number."</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>Найдет нецифровой символ (все алфавиты). <code>[^0-9]</code> - эквивалент для обычных цифр. Например, <code>/\D/</code> или <code>/[^0-9]/</code> найдет 'B' в "B2 is the suite number."</td>
</tr>
<tr>
<td><code>\f,\r,\n</code></td>
<td>Соответствующие спецсимволы form-feed, line-feed, перевод строки.</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>Найдет любой пробельный символ, включая пробел, табуляцию, переводы строки и другие юникодные пробельные символы. Например, <code>/\s\w*/</code> найдет ' bar' в "foo bar."</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>Найдет любой символ, кроме пробельного. Например, <code>/\S\w*/</code> найдет 'foo' в "foo bar."</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Символ табуляции.</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>Символ вертикальной табуляции.</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>Найдет любой словесный (латинский алфавит) символ, включая буквы, цифры и знак подчеркивания. Эквивалентно <code>[A-Za-z0-9_]</code>. Например, <code>/\w/</code> найдет 'a' в "apple," '5' в "$5.28," и '3' в "3D."</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>Найдет любой не-(лат.)словесный символ. Эквивалентно <code>[^A-Za-z0-9_]</code>. Например, <code>/\W/</code> и <code>/[^$A-Za-z0-9_]/</code> одинаково найдут '%' в "50%."</td>
</tr>
<tr>
<td><code>\<code>n</code></code></td>
<td>где <code><code>n</code></code> - целое число. Обратная ссылка на n-ю запомненную скобками подстроку. Например,  <code>/apple(,)\sorange\1/</code> найдет 'apple, orange,' в "apple, orange, cherry, peach.". За таблицей есть более полный пример.</td>
</tr>
<tr>
<td><code>\0</code></td>
<td>Найдет символ NUL. Не добавляйте в конец другие цифры.</td>
</tr>
<tr>
<td><code>\x<code>hh</code></code></td>
<td>Найдет символ с кодом <code><code>hh</code></code> (2 шестнадцатиричных цифры)</td>
</tr>
<tr>
<td><code>\u<code>hhhh</code></code></td>
<td>Найдет символ с кодом <code><code>hhhh</code></code> (4 шестнадцатиричных цифры).</td>
</tr>
</tbody>
</table>
<p>Проверка результатов: метод test.
Чтобы просто проверить, подходит ли строка под регулярное выражение, используется метод test:
<xmp>
if ( /\s/.test("строка") ) {
...В строке есть пробелы!...
}
</xmp>
<p>Метод test начинает поиск, начиная со свойства lastIndex объекта RegExp, если оно установлено.
Поиск совпадений: метод exec

<p>Метод exec возвращает массив и ставит свойства регулярного выражения.
Если совпадений нет, то возвращается null.

<p>Например, найдем одну d, за которой следует 1 или более b, за которыми одна d.
Запомнить найденные b и следующую за ними d. Регистронезависимый поиск.
<xmp>
	var myRe = /d(b+)(d)/ig;
	var myArray = myRe.exec("cdbBdbsbz");
</xmp>
</div>

<h3 class="show" onclick="Click(this)">Результат</h3>
<div>
<table border=1>
<tbody><tr>
<td class="header">Объект</td>
<td class="header">Свойство/Индекс</td>
<td class="header">Описания</td>
<td class="header">Пример</td>
</tr>
<tr>
<td rowspan="5"><code>myArray</code></td>
<td><code> </code></td>
<td>Содержимое <code>myArray</code>.</td>
<td><code>["dbBd", "bB", "d"]</code></td>
</tr>
<tr>
<td><code>index</code></td>
<td>Индекс совпадения (от 0)</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>input</code></td>
<td>Исходная строка.</td>
<td><code>cdbBdbsbz</code></td>
</tr>
<tr>
<td><code>[0]</code></td>
<td>Последние совпавшие символы</td>
<td><code>dbBd</code></td>
</tr>
<tr>
<td><code>[1], ...[<code>n</code>]</code></td>
<td>Совпадения во вложенных скобках, если есть. Число вложенных скобок не ограничено.</td>
<td><code>[1] = bB<br>
[2] = d</code></td>
</tr>
<tr>
<td rowspan="5"><code>myRe</code></td>
<td><code>lastIndex</code></td>
<td>Индекс, с которого начинать следующий поиск.</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>ignoreCase</code></td>
<td>Показывает, что был включен регистронезависимый поиск, флаг "<code>i</code>".</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>global</code></td>
<td>Показывает, что был включен флаг "<code>g</code>" поиска <code>всех</code> совпадений.</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>multiline</code></td>
<td>Показывает, был ли включен флаг многострочного поиска "<code>m</code>".</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>source</code></td>
<td>Текст паттерна.</td>
<td><code>d(b+)(d)</code></td>
</tr>
</tbody>
</table>

<p>Если в регулярном выражении включен флаг "g", Вы можете вызывать метод exec много раз для поиска последовательных совпадений в той же строке. Когда Вы это делаете, поиск начинается на подстроке str, с индекса lastIndex. Например, вот такой скрипт:
<xmp>
	var myRe = /ab*/g;
	var str = "abbcdefabh";
	while ((myArray = myRe.exec(str)) != null) {
	    var msg = "Found " + myArray[0] + ".  ";
	    msg += "Next match starts at " + myRe.lastIndex;
	    print(msg);
	}
</xmp>

<p>Этот скрипт выведет следующий текст:
<xmp>
Found abb. Next match starts at 3
Found ab. Next match starts at 9
</xmp>
<p>В следующем примере функция выполняет поиск по input. Затем делается цикл по массиву, чтобы посмотреть, есть ли другие имена.

Предполагается, что все зарегистрированные имена находятся в массиве А:
<xmp>
	var A = ["Frank", "Emily", "Jane", "Harry", "Nick", "Beth", "Rick",
	         "Terrence", "Carol", "Ann", "Terry", "Frank", "Alice", "Rick",
	         "Bill", "Tom", "Fiona", "Jane", "William", "Joan", "Beth"];
	 
	function lookup(input)
	{
	  var firstName = /\w+/i.exec(input);
	  if (!firstName)
	  {
	    print(input + " isn't a name!");
	    return;
	  }
	 
	  var count = 0;
	  for (var i = 0; i < A.length; i++)
	  {
	    if (firstName[0].toLowerCase() == A[i].toLowerCase())
	      count++;
	  }
	  var midstring = (count == 1) ? " other has " : " others have ";
	  print("Thanks, " + count + midstring + "the same name!")
	}
</xmp>
</div>

<h3 class="show" onclick="Click(this)">Строковые методы, поиск и замена</h3>
<div>
<p>Следующие методы работают с регулярными выражениями из строк.

Все методы, кроме replace, можно вызывать как с объектами типа regexp в аргументах, так и со строками, которые автоматом преобразуются в объекты RegExp.
Так что вызовы эквивалентны:
<xmp>
var i = str.search(/\s/)
var i = str.search("\\s")
</xmp>
<p>При использовании кавычек нужно дублировать \ и нет возможности указать флаги. Если регулярное выражение уже задано строкой, то бывает удобна и полная форма
<xmp>
var regText = "\\s"
var i = str.search(new RegExp(regText, "g"))
</xmp>

<h4 class="show" onclick="Click(this)">Метод search(regexp)</h4>
<div>
<p>Возвращает индекс регулярного выражения в строке, или -1.

Если Вы хотите знать, подходит ли строка под регулярное выражение, используйте метод search(аналогично RegExp-методы test). Чтобы получить больше информации, используйте более медленный метод match(аналогичный методу RegExp exec).

<p>Этот пример выводит сообщение, в зависимости от того, подходит ли строка под регулярное выражение.
<xmp>
	function testinput(re, str){
	   if (str.search(re) != -1)
	      midstring = " contains ";
	   else
	      midstring = " does not contain ";
	   document.write (str + midstring + re.source);
	}
</xmp>
</div>

<h4 class="show" onclick="Click(this)">Метод match(regexp)</h4>
<div>
<p>Если в regexp нет флага g, то возвращает тот же результат, что regexp.exec(string).
Если в regexp есть флаг g, то возвращает массив со всеми совпадениями.

<p>Чтобы просто узнать, подходит ли строка под регулярное выражение regexp, используйте regexp.test(string).
Если Вы хотите получить первый результат - попробуйте regexp.exec(string).

<p>В следующем примере match используется, чтобы найти "Chapter", за которой следует 1 или более цифр, а затем цифры, разделенные точкой. В регулярном выражении есть флаг i, так что регистр будет игнорироваться.
<xmp>
	str = "For more information, see Chapter 3.4.5.1";
	re = /chapter (\d+(\.\d)*)/i;
	found = str.match(re);
	alert(found);
</xmp>
<p>Скрипт выдаст массив из совпадений:
<xmp>
    Chapter 3.4.5.1 - полностью совпавшая строка
    3.4.5.1 - первая скобка
    .1 - внутренняя скобка
</xmp>

<p>Следующий пример демонстрирует использование флагов глобального и регистронезависимого поиска с match. Будут найдены все буквы от А до Е и от а до е, каждая - в отдельном элементе массива.
<xmp>
	var str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	var regexp = /[A-E]/gi;
	var matches = str.match(regexp);
	document.write(matches);
	 
	// matches = ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']
</xmp>
</div>

<h4 class="show" onclick="Click(this)">Замена, replace</h4>
<div>
<p>Метод replace может заменять вхождения регулярного выражения не только на строку, но и на результат выполнения функции. Его полный синтаксис - такой:
<xmp>
var newString = str.replace(regexp/substr, newSubStr/function)
</xmp>
<dl>
<dt>regexp
<dd>Объект RegExp. Его вхождения будут заменены на значение, которое вернет параметр номер 2 
<dt>substr
<dd>Строка, которая будет заменена на newSubStr. 
<dt>newSubStr
<dd>Строка, которая заменяет подстроку из аргумента номер 1. 
<dt>function
<dd>Функция, которая может быть вызвана для генерации новой подстроки (чтобы подставить ее вместо подстроки, полученной из аргумента 1). 
</dl>

<p>Метод replace не меняет строку, на которой вызван, а просто возвращает новую, измененную строку.

Чтобы осуществить глобальную замену, включите в регулярное выражение флаг "g".

<p>Если первый аргумент - строка, то она не преобразуется в регулярное выражение, так что, например,
<xmp>
var ab = "a b".replace("\\s","..") // = "a b"
</xmp>
<p>Вызов replace оставил строку без изменения, т.к искал не регулярное выражение \s, а строку "\s".

<h5 class="show" onclick="Click(this)">Спецсимволы в строке замены</h5>
<div>
<p>В строке замены могут быть такие спецсимволы:
Pattern 	Inserts
$$ 	Вставляет "$".
$& 	Вставляет найденную подстроку.
$` 	Вставляет часть строки, которая предшествует найденному вхождению.
$' 	Вставляет часть строки, которая идет после найденного вхождения.
$n or $nn 	Где n или nn - десятичные цифры, вставляет подстроку вхождения, запомненную n-й вложенной скобкой, если первый аргумент - объект RegExp.
</div>

<h5 class="show" onclick="Click(this)">Замена через функцию</h5>
<div>
<p>Если Вы указываете вторым параметром функцию, то она выполняется при каждом совпадении.

В функции можно динамически генерировать и возвращать строку подстановки.

<p>Первый параметр функции - найденная подстрока. Если первым аргументом replace является объект RegExp, то следующие n параметров содержат совпадения из вложенных скобок. Последние два параметра - позиция в строке, на которой произошло совпадение и сама строка.

Например, следующий вызов replace возвратит XXzzzz - XX , zzzz.
<xmp>
	function replacer(str, p1, p2, offset, s){
	return str + " - " + p1 + " , " + p2;
	}
	var newString = "XXzzzz".replace(/(X*)(z*)/, replacer)
</xmp>
<p>Как видите, тут две скобки в регулярном выражении, и потому в функции два параметра p1, p2.
Если бы были три скобки, то в функцию пришлось бы добавить параметр p3.

Следующая функция заменяет слова типа borderTop на border-top:
<xmp>
	function styleHyphenFormat(propertyName)
	{
	  function upperToHyphenLower(match)
	  {
	    return '-' + match.toLowerCase();
	  }
	  return propertyName.replace(/[A-Z]/, upperToHyphenLower);
	}
</xmp>

<h5>Статичные регэкспы</h5>

<p>В некоторых реализациях javascript регэкспы, заданные коротким синтаксисом /.../ - статичны. То есть, такой объект создается один раз в некоторых реализациях JS, например в Firefox. В Chrome все ок.
<xmp>
	function f() {
	  // при многократных заходах в функцию объект один и тот же
	  var re = /lalala/    
	}
</xmp>

<p>Из-за того, что lastIndex при глобальном поиске меняется, а сам объект регэкспа статичен, первый поиск увеличивает lastIndex, а последующие - продолжают искать со старого lastIndex, т.е. могут возвращать не все результаты.

При поиске всех совпадений в цикле проблем не возникает, т.к. последняя итерация (неудачная) обнуляет lastIndex.
</div>
</div>
</div>

<h3 class="show" onclick="Click(this)">Задание</h3>
<div>
Напишите скрипт, 
</div>

<hr width="40%" align="center">
</body>
</html>