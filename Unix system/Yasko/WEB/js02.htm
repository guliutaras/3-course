<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
<title>Константы, переменные, типы данных</title>
<script src="Script.js"></script>
<link rel="stylesheet" type="text/css" href="Style.css"/>
</head>
<body>

<h2>Базовые типы: Строки, Числа, Boolean</h2>
<div style="display:block">
<p>В этой статье собраны особенности базовых типов данных, которые важны для программистов.
В Javascript есть и объектные типы данных и элементарные, которые можно интерпретировать как объекты.

типы данных

<p>Элементарные - создаются простым указанием данных:
<xmp>
var orange = "Апельсин"
</xmp>
<p>Объектные - например, через оператор <code>new</code>:
<xmp>
var orange = new String("Апельсин")
</xmp>
<p>На практике, хотя для каждого элементарного типа есть соответствующий объект, использовать их не рекомендуется. Это - отмершая часть языка.
<xmp>
var ok = new Boolean(true) // не надо
</xmp>
<p>Элементарные типы автоматически интерпретируются как объекты при вызовах методов, поэтому можно, определять длину строки как:
<xmp>
alert("Апельсин".length)
</xmp>
<p>Поэтому иногда говорят, что в javascript - все объекты. Так удобно думать, но определенная разница все же есть.

<p>Например, typeof выдаст разный результат:
<xmp>
alert(typeof "test")
alert(typeof new String("test"))
</xmp>
<p>Это - еще одна причина избегать использования объектов там, где существует элементарный тип: меньше путаницы.

<p>Преобразование типа можно явным образом сделать через его название:
<xmp>
var test = Boolean("something") // true
</xmp>
<p>Кроме всем известных типов данных - в javascript есть специальное значение undefined, которое, условно говоря, обозначает что "данных нет". Не null, а данных нет. Понимайте как хотите.

<p>Далее рассмотрим особенности каждого из этих типов.
</div>

<h3 class="show" onclick="Click(this)">Number</h3>
<div>
<p>Все числа хранятся в формате float64, т.е 8 байт с плавающей точкой. В этом формате не всегда возможны точные вычисления.
Например,
<xmp>
alert(0.1+0.2)  // выведет не 0.3!
</xmp>

<h4>Маскировка ошибок</h4>

<p>При операциях с Number - никогда не происходят ошибки. Зато могут быть возвращены специальные значения:
<xmp>
1/0		//     Number.POSITIVE_INFINITY (плюс бесконечность)
-1/0	//     Number.NEGATIVE_INFINITY (минус бесконечность)
Number(“something”)	//    NaN (Not-a-Number, результат ошибочной операции)
</xmp>
<p>Бесконечность бывает полезно использовать в обычном коде. 
Например, положительная бесконечность <code>Number.POSITIVE_INFINITY</code> больше любого <code>Number</code>, и даже больше самой себя.

<h4>NaN - особый результат</h4>
<p> Любая математическая операция с NaN дает NaN:
<xmp>
        NaN + 1 = NaN		//    NaN не равен сам себе:
        NaN == NaN 			// false
 //   Можно проверить с помощью функции isNaN:
        isNaN(NaN) // true
</xmp>

<h4>Полезные методы</h4>
<p>Округление до нужной точности после запятой. Для этого используется метод toFixed.
<xmp>
0.1234.toFixed(2)  = 0.12
</xmp>
<h4>Конвертация в число</h4>
 
<p>Стандартно конвертация осуществляется вызовом Number(). Можно и попроще: +str.
<xmp>
	// эквивалентные записи
	var str = "002"
	var a = Number(str) // 2
	// нечисла превращаются в NaN
	+"0.1"  // => 0.1
	+"0.1z" // => Number.NaN
</xmp>
<p>Кроме жесткой конвертации есть и более мягкая фильтрация в число:
<xmp>
	// обрезается все после числа
	parseFloat("0.1zf") = 0.1
	parseInt("08f.4", 10) = 8
	// тут числа вообще нет, поэтому NaN
	parseFloat("smth") = Number.NaN
</xmp>
<code>parseFloat</code>, <code>parseInt</code> переводят  строки в числа слева направо, пока это возможно. Если вообще невозможно - то NaN.

Второй аргумент <code>parseInt</code> - основание системы счисления. Если его нет, то система сама пытается угадать систему счисления:
<xmp>
	parseInt("0x10") = 16 // т.к 0x обозначает 16-ричную систему
	parseInt("010") = 8 // т.к ведущий 0 обозначает 8-ричную систему
	// если хотите без сюрпризов - указывайте основание явно
	parseInt("010",10) = 10
</xmp>

<h4>Математика</h4>

<p>Все математические функции находятся в "пакете(статическом объекте)" <code>Math</code>. Не то, чтобы в javascript есть реальные пакеты, просто так получилось.
<xmp>
    Math.floor(x) /
	Math.round(x) / 
	Math.ceil(x) - округление
    Math.abs(x) - модуль числа
    Math.sin(x) и т.д
</xmp>
</div>

<h3 class="show" onclick="Click(this)">String</h3>
<div>
<p>Строки в javascript - полностью юникодные, т.е. каждый символ занимает в памяти 2 байта.
Кавычки двойные и одинарные работают одинаково.
    Можно указывать юникодные символы через <code>\uXXXX</code>:
        "звездочка: <code>\u002a</code>". 
    
<p>Встроены регулярные выражения, методы <code>replace / match</code>:
<xmp>
        "превед медвед".replace(/(.*?)\s(.*)/, "$2, $1!") // => медвед, превед!
</xmp>
<p>Как это обычно и бывает, в регулярках символ <code>\w</code> обозначает латинские буквоцифры 
или подчеркивание, но не кириллицу.

<p>Длина строки хранится в свойстве <code>length</code>.
</div>


<h3 class="show" onclick="Click(this)">Boolean</h3>
<div>
<p>В javascript - особый список значений, которые при приведении к <code>Boolean</code> становятся <code>false</code>. 
Он отличается, например, от аналогичного списка в PHP.
Так значения <code>false</code>, <code>null</code>, <code>undefined</code>, <code>“”</code>, <code>0</code>,
<code>Number.NaN</code> дают ложь, все остальное - истину.

<p>Чтобы привести значение к булевому - используется либо явное указание типа: 
<code>Boolean</code>, либо двойное отрицание: <code>!!a</code>
</div>

<h3 class="show" onclick="Click(this)">Задание</h3>
<div>

</div>

<hr width="40%" align="center">
</body>
</html>