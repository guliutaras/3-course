<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
<title>Функции в JavaScript</title>
<script src="Script.js"></script>
<link rel="stylesheet" type="text/css" href="Style.css"/>
</head>
<body>

<h2>Функции в JavaScript</h2>

<h3 class="show" onclick="Click(this)">Создание функций</h3>
<div>
<p>Существует 3 способа создать функцию. Основное отличие в результате их работы - в том, 
что именованная функция видна везде, а анонимная - только после объявления:
<xmp>
function имя(параметры) {
...
}
</xmp>
<p>Именованные функции доступны везде в области видимости

<xmp>
var имя = function(параметры) {
…
}
</xmp>

<xmp>
var имя = new Function(параметры, '...')
</xmp>

<p>Анонимные - доступны только с момента объявления. Синтаксис <code>new Function</code> используется редко, 
в основном для получения функции из текста, например, динамически загруженного с сервера в процессе выполнения скриптов.
</div>

<h3 class="show" onclick="Click(this)">Функции - объекты</h3>
<div>
<p>В javascript функции являются полноценными объектами встроенного класса Function. Именно поэтому их можно присваивать переменным, передавать и, конечно, у них есть свойства:
<xmp>
	function f() {
	    ...
	}
	f.test = 6
	...
	alert(f.test) // 6
</xmp>

<p>Свойства функции доступны и внутри функции, так что их можно использовать как статические переменные.
Например,
<xmp>
	function func() {
	    var funcObj = arguments.callee
	 
	    funcObj.test++
	    alert(funcObj.test)
	}
	func.test = 1
	func()
	func()
</xmp>

<p>В начале работы каждая функция создает внутри себя переменную <code>arguments</code> и присваивает <code>arguments.callee</code> ссылку на себя. 
Так что <code>arguments.callee.test</code> - свойство <code>func.test</code>, т.е статическая переменная <code>test</code>.

В примере нельзя было сделать присвоение:
<xmp>
var test = arguments.callee.test
test++
</xmp>
так как при этом операция <code>++</code> сработала бы на локальной переменной <code>test</code>, а не на свойстве <code>test</code> объекта функции.

<p>Объект <code>arguments</code> также содержит все аргументы и может быть преобразован в массив (хотя им не является), об этом - ниже, 
в разделе про параметры.
</div>

<h3 class="show" onclick="Click(this)">Области видимости</h3>
<div>
<p>Каждая функция, точнее даже каждый запуск функции задает свою индивидуальную область видимости.

<p>Переменные можно объявлять в любом месте. Ключевое слово var задает переменную в текущей области видимости. Если его забыть, то переменная попадет в глобальный объект window. Возможны неожиданные пересечения с другими переменными окна, конфликты и глюки.
javascript function

<p>В отличие от ряда языков, блоки не задают отдельную область видимости. Без разницы - определена переменная внутри блока или вне его. Так что эти два фрагмента совершенно эквивалентны:
javascript function

<p>Заданная через var переменная видна везде в области видимости, даже до оператора var. Для примера сделаем функцию, которая будет менять переменную, var для которой находится ниже.
Например:
<xmp>
	function a() {
	    z = 5 // поменяет z локально..
	 
	    // .. т.к z объявлена через var
	    var z
	}
	 
	// тест
	delete z // очистим на всякий случай глобальную z
	a()
	 
	alert(window.z)  // => undefined, т.к z была изменена локально
</xmp>
<p>Каждое выполнение функции хранит все переменные в специальном объекте с кодовым именем <code>[[scope]]</code>, который нельзя получить в явном виде, но он есть .

Каждый вызов var... - всего лишь создает новое свойство этого объекта, а любое упоминание переменной - первым делом ищется в свойствах этого объекта.

Такова внутренняя структура "области видимости" - это обыкновенный объект. Все изменения локальных переменных являются изменениями свойств этого неявного объекта.

Обычно после того, как функция закончила выполнение, ее область видимости <code>[[scope]]</code>, т.е весь набор локальных переменных удаляется.

</div>

<h3 class="show" onclick="Click(this)">Параметры функции</h3>
<div>

<p>Функции можно запускать с любым числом параметров.

Если функции передано меньше параметров, чем есть в определении, то отсутствующие считаются <code>undefined</code>.

<p>Следующая функция возвращает время <code>time</code>, необходимое на преодоление дистанции <code>distance</code> с равномерной скоростью <code>speed</code>.


<p>При первом запуске функция работает с аргументами distance=10, speed=undefined. Обычно такая ситуация, если она поддерживается функцией, предусматривает значение по умолчанию:
<xmp>
// если speed - ложное значение(undefined, 0, false...) - подставить 10
speed = speed || 10
</xmp>
<p>Оператор <code>||</code> в яваскрипт возвращает не <code>true/false</code>, а само значение (первое, которое приводится к <code>true</code>).

<p>Поэтому его используют для задания значений по умолчанию. В нашем вызове <code>speed</code> будет вычислено как <code>undefined || 10 = 10</code>.
Поэтому результат будет 10/10 = 1.

<p>Второй запуск - стандартный.

<p>Третий запуск задает несколько дополнительных аргументов. В функции не предусмотрена работа с дополнительными аргументами, поэтому они просто игнорируются.

<p>Ну и в последнем случае аргументов вообще нет, поэтому distance = undefined, и имеем результат деления undefined/10 = NaN (Not-A-Number, произошла ошибка).
</div>

<h3 class="show" onclick="Click(this)">Работа с неопределенным числом параметров</h3>
<div>

<p>Непосредственно перед входом в тело функции, автоматически создается объект arguments, который содержит

    Аргументы вызова, начиная от нуля
    Длину в свойстве length
    Ссылку на саму функцию в свойстве callee

Например,
<xmp>
	function func() {
	    for(var i=0;i<arguments.length;i++) {
	        alert("arguments["+i+"] = "+arguments[i])
	    }
	}
	func('a','b',true)
	 
	// выведет
	// arguments[0] = a
	// arguments[1] = b
	// arguments[2] = true
</xmp>

<p>Свойство <code>arguments</code> похоже на массив, т.к у него есть длина и числовые индексы. 
На самом деле <code>arguments</code> не принадлежит классу <code>Array</code> и не содержит его методов, таких как <code>push</code>, <code>pop</code> и других.

Если все же хочется воспользоваться этими методами, например, чтобы вызвать другую функцию с теми же аргументами, но кроме первого, можно создать из arguments настоящий массив:
<xmp>
	var args = Array.prototype.slice.call(arguments)
	// .. теперь args - настоящий массив аргументов ..
	args.shift()
	...
</xmp>

<p>Вызвать функцию для массива аргументов можно при помощи apply:
<xmp>
var func = function(a,b) { alert(a+b) }
var arr = [1,2]
func.apply(null, arr)  // => alert(3)
</xmp>
</div>

<h3 class="show" onclick="Click(this)">Пример передачи функции по ссылке</h3>
<div>
<p>Функцию легко можно передавать в качестве аргумента другой функции.

Например, map берет функцию func, применяет ее к каждому элементу массива arr и возвращает получившийся массив:
<xmp>
	var map = function(func, arr) {
	    var result = [ ]
	    for(var i=0; i<arr.length; i++) {
	        result[i] = func(arr[i])
	    }
	    return result
	}
</xmp>
<p>Пример использования:
<xmp>
map(run, [10, 20, 30])  // = [1,2,3]
</xmp>
<p>Или можно создать анонимную функцию непосредственно в вызове map:
<xmp>
// анонимная функция утраивает числа
map( function (a) { return a*3 } ,  [1,2,3])  // = [3,6,9]
</xmp>
</div>

<h3 class="show" onclick="Click(this)">Сворачивание параметров в объект</h3>
<div>
<p>Бывают функции, аргументы которых сильно варьируются.
Например:
<xmp>
	// можно указать только часть аргументов
	// не указанные - вычисляются или берутся по умолчанию
	function resize(toWidth, toHeight,  saveProportions, animate)  {
	    // значения по умолчанию
	    saveProportions = saveProportions || true
	    animate = animate || true
	    toHeight = toHeight || ...
	}
</xmp>
<p>Вызов с необязательными параметрами приходится делать так:
<xmp>
resize(100, null, null, true)
</xmp>

<p>Чтобы избежать лишних null и сделать код более понятным, используют нечто вроде "keyword arguments", существующих в Python и Ruby. Для этого много параметров пакуют в единый объект:
<xmp>
	function resize(setup)  {
	    // значения по умолчанию
	    var saveProportions = setup.saveProportions || true
	    var animate = setup.animate || true
	    var toHeight = setup.toHeight || ...
	}
</xmp>
<p>Вызов теперь делается гораздо проще:
<xmp>
	var setup = {toWidth: 100, animate: true}
	 
	resize(setup)
	// или
	resize({toWidth: 100, animate: true})
</xmp>

<p>Так - куда понятнее. А если параметров больше 5, то вообще - единственный нормальный способ.

<p>Кроме того, с объектом можно удобнее делать последовательности вызовов вроде:
<xmp>
	var setup = {toWidth: 100, animate: true, saveProportions: false}
	 
	resize(setup)
	 
	setup.toWidth = 200
	resize(setup)
</xmp>


</div>

<h3 class="show" onclick="Click(this)">Задание</h3>
<div>
Напишите скрипт, 
</div>

<hr width="40%" align="center">
</body>
</html>